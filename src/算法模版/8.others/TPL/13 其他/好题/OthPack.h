for (int i = 1; i <= n; i++)
{
	cin >> s; // 物品组数
	for (int j = 1; j <= s; j++)
		cin >> c[j] >> w[j]; // 组中每个物品的属性
	for (int j = V; j >= 0; j--)
		for (int k = 1; k <= s; k++)
			if (j >= c[k])
				f[j] = max(f[j], f[j - c[k]] + w[k]);
	// 由于每组物品只能选一个，所以可以覆盖之前组内物品最优解的来取最大值
}

// 分组背包
// 分组背包，通俗的讲就是，
// 给你N组物品，然后每一组你至多选择一个物品(也可以不选),
// 每个物品都有自己的体积和价值，现在给你一个容里为M的背包，
// 让你用这个背包装物品，使得物品价值总和最大.
for (int i = 1; i <= n; i++)
	for (int j = 0; j <= m; j++)
		for (int k = 1; k <= s[i]; k++) // s[i]表示第i组物品的个数
			if (j >= v[i][k])			// 剩余的背包容量j大于第i组的第k个物品的体积
				f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);
// 这里我们还可以对空间进行优化，我们可以观察到，
// f[i][…]只会用到f[i-1][…]的值，所以数组的第一维的空间
// 完全可以用滚动数组的方式处理掉，但是如何不影响状态转移呢，
// 我们来看滚掉之后的状态转移方程，
//  f [ j ] = m a x ( f [ j ] , f [ j ? v [ i ] [ k ] ] + w [ i ] [ k ] )
//  f[j] = max(f[j],f[j-v[i][k]]+w[i][k]) f[j]=max(f[j],f[j?v[i][k]]+w[i][k])
//  ,这里的max里面的 f [ j ] 和 f [ j ? v [ i ] [ k ] ] f[j]和f[j-v[i][k]] f[j]和f[j?v[i][k]]其实是 f [ i ? 1 ] [ j ] 和 f [ i ? 1 ] [ j ? v [ i ] [ k ] ] f[i-1][j]和f[i-1][j-v[i][k]] f[i?1][j]和f[i?1][j?v[i][k]],而不是 f [ i ] [ j ] 和 f [ i ] [ j ? v [ i ] [ k ] ] f[i][j]和f[i][j-v[i][k]] f[i][j]和f[i][j?v[i][k]]，所以我们需要对体积的遍历做一些修改，从大到小循环，如果还是从小到大循环的话，那么这里的 f [ j ] 和 f [ j ? v [ i ] [ k ] ] f[j]和f[j-v[i][k]] f[j]和f[j?v[i][k]]的含义就有可能是 f [ i ] [ j ] 和 f [ i ] [ j ? v [ i ] [ k ] ] f[i][j]和f[i][j-v[i][k]] f[i][j]和f[i][j?v[i][k]]，而不是我们需要的 f [ i ? 1 ] [ j ] 和 f [ i ? 1 ] [ j ? v [ i ] [ k ] ] f[i-1][j]和f[i-1][j-v[i][k]] f[i?1][j]和f[i?1][j?v[i][k]]，可以模拟一下就明白了，只靠想的话有点抽象.

// 依赖背包
// 什么是依赖背包，顾名思义就是具有依赖属性，
// 这种背包常见于树形结构上面，
// 例如：一棵树有N个节点，
// 每一个节点放有一个物品，
// 这些物品有自己的体积和价值，
// 但是如果你要选择v好节点的物品，
// 那么必须先选择v的父亲节点上的物品(所谓的依赖关系)，
// 现在你有容里为M的背包，
// 问你选择物品的最大权值和是多少.
/*这里i最小为v[u]因为你要选子节点的话，u这个节点必选，给u留空间*/
for (int i = m; i >= v[u]; i--)
	for (int k = 0; k <= i - v[u]; i++)
		f[u][i] = max(f[u][i], f[u][i - k] + f[s][k]); // s是u的子节点