```c++
// S(n,m) 第二类斯特林数
	ll n, m;
	FIN(n, m);

	if (n - m < 0)
	{
		cout << 0 << EDL;
		return;
	}
	if (n - m == 0)
	{
		cout << 1 << EDL;
		return;
	}
	
	ac.Init(SZ - 1);
	
	mint ans = 1;
	ans *= ac.fac_inv[m];
	
	mint sum = 0;
	FOR(k, 0, m)
	{
		mint tmp = ac.C(m, k);
		tmp *= mint(m - k).Pow(n);
		tmp *= mint(-1).Pow(k);
		sum += tmp;
	}
	
	ans *= sum;
	cout << ans << EDL;
```



![](https://pic3.zhimg.com/80/v2-7a0d47e216dac4fabc94f5bb7dc2b7d2_720w.webp)

其中(0,1,1)情况的方法数改为 $$\sum^r_{k=1} S(n,k)$$



1.球同，盒不同，无空箱
C(n-1,m-1), n>=m
0, n<m
使用插板法：n个球中间有n-1个间隙，现在要分成m个盒子，而且不能有空箱子，所以只要在n-1个间隙选出m-1个间隙即可

2.球同，盒不同，允许空箱
C(n+m-1,m-1)
我们在第1类情况下继续讨论，我们可以先假设m个盒子里都放好了1个球，所以说白了就是，现在有m+n个相同的球，要放入m个不同的箱子，没有空箱。也就是第1种情况

3.球不同，盒相同，无空箱
第二类斯特林数dp[n][m]
dp[n][m]=m*dp[n-1][m]+dp[n-1][m-1],1<=m<n
dp[k][k]=1,k>=0
dp[k][0]=0,k>=1
0,n<m
这种情况就是第二类斯特林数，我们来理解一下这个转移方程。
对于第n个球，如果前面的n-1个球已经放在了m个箱子里，那么现在第n个球放在哪个箱子都是可以的，所以m*dp[n-1][m];
如果前n-1个球已经放在了m-1个箱子里，那么现在第n个球必须要新开一个箱子来存放，所以dp[n-1][m-1]
其他的都没法转移过来

4.球不同，盒相同，允许空箱
sigma dp[n][i],0<=i<=m,dp[n][m]为情况3的第二类斯特林数
这种情况就是在第3种情况的前提下，去枚举使用的箱子的个数

5.球不同，盒不同，无空箱
dp[n][m]*fact[m],dp[n][m]为情况3的第二类斯特林数,fact[m]为m的阶乘
因为球是不同的，所以dp[n][m]得到的盒子相同的情况，只要再给盒子定义顺序，就等于现在的答案了

6.球不同，盒不同，允许空箱
power(m,n) 表示m的n次方
每个球都有m种选择，所以就等于m^n

7.球同，盒同，允许空箱
dp[n][m]=dp[n][m-1]+dp[n-m][m], n>=m
dp[n][m]=dp[n][m-1], n<m
边界dp[k][1]=1,dp[1][k]=1,dp[0][k]=1
现在有n个球，和m个箱子，我可以选择在所有箱子里面都放上1个球，也可以不选择这个操作。
如果选择了这个操作，那么就从dp[n-m][m]转移过来
如果没有选择这个操作，那么就从dp[n][m-1]转移过来

8.球同，盒同，无空箱
dp[n-m][m],dp同第7种情况,n>=m
0, n<m
因为要求无空箱，我们先在每个箱子里面放1个球，然后还剩下n-m个球了，再根据情况7答案就出来了